{% liquid
  comment

    ABOUT
    --------
    Myntr DataLayer
    v1.0

    DESCRIPTION
    -------------
    This file handles implementation of GA4 in Shopify themes.
    It's purpose is to track user interactions and push these to the data layer.
    This file includes:
    - Tracking the cart and checkout steps
    - Tracking adds to and removes from the cart
    - Tracking product detail views
    - Tracking product clicks
    - Tracking product views (impressions)
    - Tracking promotion views (impressions)
    - Tracking promotion clicks

    CUSTOM CLIENT EVENTS
    ---------------------
    Themes may require specific events depending on installed 3rd parties/apps.
    These specific events are marked by the following comment:
    // #CUSTOM CLIENT EVENT
    You can search for this comment line within the GA4 files in order to find & modify custom events.

    REQUIREMENTS
    --------------
    1. Insert code into <head> within theme.liquid & checkout.liquid
    <!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','{{settings.gtm_id}}');</script><!-- End Google Tag Manager -->

    2. Insert code into <body> within theme.liquid & checkout.liquid
    <!-- Google Tag Manager (noscript) --><noscript><iframe src="https://www.googletagmanager.com/ns.html?id={{settings.gtm_id}}" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><!-- End Google Tag Manager (noscript) -->

    3. Add schema to 'settings_schema.json' and then input the client's GTM ID
        {
          "name": "GTM Data Layer",
          "settings": [
            {
              "type": "text",
              "id": "gtm_id",
              "label": "GTM ID",
              "info": "Insert Google Tag Manager ID"
            },
            {
              "type": "checkbox",
              "id": "gtm_debug",
              "label": "Enable debugging",
              "info": "If checked, events will be pushed to the 'myntrLayer' object and development logs will show in the browser console.",
              "default": false
            }
          ]
        }

    4. Add new snippet: 'datalayer.liquid'
    5. Add new snippet: 'product-datalayer.liquid'
    6. Add new snippet: 'datalayer-promo-attrs.liquid'
    7. Add new snippet: 'get-query-string.liquid'
    8. Add new product template: 'product.datalayer.liquid'
    9. Add new cart template: 'cart.datalayer.liquid'
    10. Render 'datalayer' snippet near end of </body> tag on theme.liquid and checkout.liquid

  endcomment
%}
{% comment %}
  Shopify formatMoney function
{% endcomment %}
<script>
  var Shopify = Shopify || {};
  // ---------------------------------------------------------------------------
  // Money format handler
  // ---------------------------------------------------------------------------
  Shopify.money_format = {% raw %}"${{amount}}"{% endraw %};
  Shopify.formatMoney = function(cents, format) {
    if (typeof cents == 'string') { cents = cents.replace('.',''); }
    var value = '';
    var placeholderRegex = /\{\{\s*(\w+)\s*\}\}/;
    var formatString = (format || this.money_format);

    function defaultOption(opt, def) {
      return (typeof opt == 'undefined' ? def : opt);
    }

    function formatWithDelimiters(number, precision, thousands, decimal) {
      precision = defaultOption(precision, 2);
      thousands = defaultOption(thousands, ',');
      decimal   = defaultOption(decimal, '.');

      if (isNaN(number) || number == null) { return 0; }

      number = (number/100.0).toFixed(precision);

      var parts   = number.split('.'),
          dollars = parts[0].replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1' + thousands),
          cents   = parts[1] ? (decimal + parts[1]) : '';

      return dollars + cents;
    }

    switch(formatString.match(placeholderRegex)[1]) {
      case 'amount':
        value = formatWithDelimiters(cents, 2);
        break;
      case 'amount_no_decimals':
        value = formatWithDelimiters(cents, 0);
        break;
      case 'amount_with_comma_separator':
        value = formatWithDelimiters(cents, 2, '.', ',');
        break;
      case 'amount_no_decimals_with_comma_separator':
        value = formatWithDelimiters(cents, 0, '.', ',');
        break;
    }

    return formatString.replace(placeholderRegex, value);
  };
</script>

<script>
  (()=>{
    try {
      /*
        =========================================================================================
          GLOBAL VARIABLES AND SELECTORS
        =========================================================================================
      */

      window.dataLayer = window.dataLayer || []; // init data layer if it does not already exist

      const myntrAnalytics = {
        dynamicCart: true,  // if cart is dynamic (meaning no refresh on cart add) set to true
        debug: {{ settings.gtm_debug }}, // if true, console messages will be displayed
        sessionStorageProductClick: 'datalayer:product:click',
        sessionStorageEngagementEmail: 'datalayer:engagement:email'
      };

      if(myntrAnalytics.debug){
        console.log(`%c snippets/datalayer.liquid loaded`, "color:green;font-size:16px;");
        window.myntrLayer = window.myntrLayer || [];
      }

      let myntrSelectors = {
        dynamicCartForm: ['[data-datalayer-trigger="view_dynamic_cart"]'],
        promotion: ['[data-datalayer-trigger="view_promotion"]'],
        itemList: ['[data-datalayer-trigger="view_item_list"]'],
        accountRegister: ['[data-datalayer-trigger="account_register"]'],
        accountLogin: ['[data-datalayer-trigger="account_login"]'],
        navigationClickTrigger: ['#main-nav a','.mobile-menu a', '[data-datalayer-trigger="navigation_click"]'],
        navigationClickTriggerLocation: ['[data-datalayer-navigation-click-location]'],
        emailOptIn: ['[data-datalayer-trigger="email_optin"]']
      };

      // Add to Cart Locations
      const add_to_cart_locations = {
        pdp_add_to_cart: 'Product Page Add To Cart',
        pdp_quick_view: 'Product Page Quick Add',
        plp_quick_view: 'Collection Page Quick Add',
        mini_cart_upsell: 'Mini Cart Upsell',
        pdp_upsell: 'Product Page Upsell',
        cart_upsell: 'Cart Page Upsell',
        search_page_add_to_cart: 'Search Page Add To Cart',
        search_page_quick_view: 'Search Page Quick Add',
        home_page_add_to_cart: 'Home Page Add To Cart',
        home_page_quick_view: 'Home Page Quick Add',
        landing_page_add_to_cart: 'Landing Page Add To Cart',
        landing_page_quick_view: 'Landing Page Quick Add',
        cart_page_add_to_cart: 'Cart Page Add To Cart',
        cart_page_quick_view: 'Cart Page Quick Add',
        mini_cart_qty_increase: 'Mini Cart Quantity Increase',
        mini_cart_remove: 'Mini Cart Remove Item',
        mini_cart_qty_decrease: 'Mini Cart Quantity Decrease',
        cart_page_remove: 'Cart Page Remove Item',
        cart_page_qty_increase: 'Cart Page Quantity Increase',
        cart_page_qty_decrease: 'Cart Page Quantity Decrease',
      }

      // view item list observer options.
      const itemListOptions = { root: null, rootMargin: '0px', threshold: 0.05 }; // we only need to see a little bit of the list container to trigger the intersection
      const itemRowOptions = { root: null, rootMargin: '0px', threshold: 0.90 }; // we only want to trigger the view when we have the majority of the row in view.

      // Currency Code
      const dl_currency_code = "{{ cart.currency.iso_code }}";

      // Format Money
      function formatPrice(price) {
        return parseFloat(Shopify.formatMoney(price, {% raw %}'{{amount}}'{% endraw %}).replaceAll(',',''))
      }

      // Push Data Layer Event
      function pushEvent(event){
        if(myntrAnalytics.debug) {
          console.log("myntrLayer pushing event: ", event);
          window.myntrLayer.push(event)
        } else {
          window.dataLayer.push(event)
        }
      }

      /*
        =========================================================================================
          Event Listeners and Observers
        =========================================================================================
      */

      function initEventListeners(){
        if(myntrAnalytics.debug) console.log(`%c initEventListeners() called.`, "color:green;font-size:16px;");

        // #CUSTOM CLIENT EVENT - Selected Swatch Change
        {% if template contains 'product' %}
          // Initialize pdp swatch change event listener
          document.addEventListener('pdp:swatch:change', (data) => {
            fetch(`/products/${data.detail.handle}?view=datalayer`, { method: 'GET' })
            .then(response => response.json())
            .then((data) => {
              const item = data;
              pushViewItem(item);
            })
            .catch((error) => {
              console.error(error);
            });
          },false);
        {% endif %}

        // Initialize add_to_cart event listeners
        document.addEventListener('cart:item:added', (data) => {
          pushAddToCart(data);
        },false);

        // Initialize cart item updated event listeners
        document.addEventListener('cart:item:updated', (data) => {
          pushCartItemQuantityChange(data);
        },false);

        // Initialize product click event listeners
        document.addEventListener('click', function(event) {
          const trigger = event.target;
          let link = null;

          if (trigger.matches('a[href]')){
            link = trigger;
          }else{
            link = trigger.closest('a[href]')
          }

          if(!link || !link.href.includes('products/')) return;

          sessionStorage.setItem(myntrAnalytics.sessionStorageProductClick,link.href);

        }, false);

        // Default Shopify contact form submit, part 1.
        // on submit of a contact form the grab the email.
        document.addEventListener('submit', function(event) {
          const trigger = event.target;
          const emailInput = trigger.querySelector('input[name="contact[email]"]');
          if(!emailInput) return;
          const email = emailInput.value;
          sessionStorage.setItem(myntrAnalytics.sessionStorageEngagementEmail, email);
        }, false);

        // ..OR.. create simpler action below

        // Initialize footer email optin
        {% comment %} document.querySelectorAll(myntrSelectors.emailOptIn).forEach(form => {
          form.addEventListener('submit', function (e) {
            if(myntrAnalytics.debug) console.log(`%c email_optin event`, "color:green;font-size:16px;");
            pushEvent({
              'event': 'email_optin'
            });
          });
        }); {% endcomment %}

        // Initialize select_promotion event listeners
        const selectPromotionTriggers = document.querySelectorAll(myntrSelectors.promotion);
        selectPromotionTriggers.forEach((trigger) => {
          trigger.addEventListener('click', (event) => pushSelectPromotion(trigger, event));
        });

        // Initialize navigation_click event listeners
        const navigationClickTriggers = document.querySelectorAll(myntrSelectors.navigationClickTrigger);
        navigationClickTriggers.forEach((trigger) => {
          trigger.addEventListener('click', () => pushNavigationClick(trigger));
        });

        // Initialize Klaviyo email optin
        window.addEventListener("klaviyoForms", (data) => {
          if(myntrAnalytics.debug) console.log(`%c klaviyoEmailOptIn`, "color:green;font-size:16px;");

          if(data.detail.type != 'submit') return;
          if(!data.detail.metaData) return;

          pushEvent({
            'event': 'email_optin'
          });

        },false);

      }


      function initObservers(){
        if(myntrAnalytics.debug) console.log(`%c initObservers() called.`, "color:green;font-size:16px;");

        // Initialize view_promotion observer
        initViewPromotionObserver();

        // Initialize view_item_list observer -- (product list viewed)
        initViewItemListObserver();

        // Initialize view_dynamic_cart observer -- (minicart view)
        initViewDynamicCartObserver();

        // #CUSTOM CLIENT EVENT - Quick View Item View
        // Initialize view_item observer -- (quick view)
        initViewDynamicProductObserver();

        // #CUSTOM CLIENT EVENT - Bounce Exchange Email
        // Initialize bounce exchange observer, used for email optin.
        initBounceExchangeObserver();

        // #CUSTOM CLIENT EVENT - Friend Buy Email
        // Initialize friend buy observer, used for email optin
        initFriendbuyObserver();
      }

      /**
      * Observe Promotions
      */
      function initViewPromotionObserver() {
        const viewPromotionTargets = document.querySelectorAll(myntrSelectors.promotion);
        const options = {
          root: null,
          rootMargin: '0px',
          threshold: 0.9
        };

        const viewPromotionObserver = new IntersectionObserver((entries, observer) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              pushViewPromotion(entry.target);
              observer.unobserve(entry.target); // we no longer want to trigger the view event when we come across this element
            }
          });
        }, options);

        // attach the observer to all targets
        viewPromotionTargets.forEach(target => {
          viewPromotionObserver.observe(target);
        });
      }

      /*
        Bounce Exchange observer
        (TODO: Convert to an event listener for a specifc Bounce Exchange event)
      */
      function initBounceExchangeObserver() {
        function handleEmailForm(form, campaignId) {
          // Check if the form contains an input with the name 'email'
          const emailInput = form.querySelector('input[name="email"]');
          if (!emailInput) {
            return;
          }
          // we only want to deal with forms that take in email...
          // do a view event for this form to start us off...
          const formPrimaryContent = form.querySelector('.bx-group-primary .bx-row-text-headline');
          let incentiveMessaging = "";
          if(formPrimaryContent){
            incentiveMessaging = formPrimaryContent.innerText;
          }
          if(myntrAnalytics.debug) console.log(`%c bounceExchange view`, "color:green;font-size:16px;");
          // send some extra 'source' and 'campaign_id' data just so we can track back to where we got this event from.
          // set the event to "email_optin_view_incentive" to emphasize this was a view.
          pushEvent({
            'event': 'view_email_optin_incentive',
            'source': 'Bounce Exchange',
            'campaign_id': campaignId,
            'optin_type': incentiveMessaging
          });
          // modify the onsubmit attribute of the form, to hopefully trigger the official optin event.
          let onsubmitValue = form.getAttribute('onsubmit');
          if (onsubmitValue.endsWith(' return false')) {
            onsubmitValue = onsubmitValue.replace(' return false', '');
            form.setAttribute('onsubmit', onsubmitValue);
          }
          // Attach a submit event listener to the form
          form.addEventListener('submit', (event) => {
            event.preventDefault();
            if(myntrAnalytics.debug) console.log(`%c bounceExchange submit`, "color:green;font-size:16px;");
            pushEvent({
              'event': 'email_optin_incentive',
              'source': 'Bounce Exchange',
              'campaign_id': campaignId,
              'optin_type': incentiveMessaging
            });
          });
        }

        function handleBxcForms(node) {
          // grab the campaign id
          const campaignId = node.id.split('bx-campaign-')[1];

          // Look for a form within the div, a bounce exchange pop up can have multiple.
          let forms = node.querySelectorAll('form[id^="bx-form-"]');
          if (forms) {
            forms.forEach((form)=>{
              if(myntrAnalytics.debug) console.log("form: ", form);
              handleEmailForm(form, campaignId);
            });
          }
        }

        const bounceExchangeObserver = new MutationObserver((mutationsList) => {
          mutationsList
            .flatMap(mutation => Array.from(mutation.addedNodes))
            .filter(node => node.nodeName === 'DIV' && node.classList.contains('bxc'))
            .forEach(node => {
              // if(myntrAnalytics.debug) console.log('Bounce Exchange element injected into the DOM', node);
              // If bx-impress is already present, handleBxcForms immediately
              if(node.classList.contains('bx-impress')) {
                handleBxcForms(node);
              } else {
                // Otherwise, set up an observer to wait for it to be added
                const classObserver = new MutationObserver((classMutations) => {
                  for(let classMutation of classMutations) {
                    if(classMutation.type === 'attributes' && classMutation.attributeName === 'class' && node.classList.contains('bx-impress')) {
                      // Bounce Exchange element is now visible
                      // if(myntrAnalytics.debug) console.log('Bounce Exchange element is now visible');
                      handleBxcForms(node);
                      classObserver.disconnect();
                      break;
                    }
                  }
                });
                classObserver.observe(node, {attributes: true});
              }
            });
        });

        const config = { childList: true, subtree: true, attributes: true };
        bounceExchangeObserver.observe(document.body, config);

      }

      /*
        Friendbuy observer
      */
      function initFriendbuyObserver() {
        const friendBuyFormSelector = '[id^="fbt-overlay-"]';
        function handleFbElement(node) {
          if(myntrAnalytics.debug) console.log("handleFbtElement");
          // send the view event with 'friendly' source.
          if(myntrAnalytics.debug) console.log(`%c friendbuy view`, "color:green;font-size:16px;");
          pushEvent({
            'event': 'view_email_optin_incentive',
            'source': 'friendbuy',
            'campaign_id': '',
            'optin_type': ''
            // leaving campaign_id and optin_type empty, since we cannot source those.
          });
        }

        const friendbuyObserver = new MutationObserver((mutationsList) => {
          for(let mutation of mutationsList) {
            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
              for(let node of mutation.addedNodes) {
                if(node.nodeType === Node.ELEMENT_NODE && node.matches(friendBuyFormSelector)){
                  // if(myntrAnalytics.debug) console.log('Friendbuy element injected into the DOM', node);
                  friendbuyIntersectionObserver.observe(node);
                }
              }
            }
          }
        });

        // friendbuy overlays are injected when the button is clicked.
        const config = { childList: true, subtree: true, attributes: true };
        friendbuyObserver.observe(document.body, config);

        const friendbuyIntersectionObserver = new IntersectionObserver((entries, observer) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              // if(myntrAnalytics.debug) console.log("Intersecting a friendbuy form.");
              handleFbElement(entry.target);
              observer.unobserve(entry.target);
            }
          });
        }, { threshold: 0 });
      }

      /**
      * Observe the row of an item list.
      */
      function observeListRows(itemList, items, rowItemCount) {
        for(let i = 0; i < items.length; i += rowItemCount) {
          const rowItems = items.slice(i, i + rowItemCount);
          const rowObserver = new IntersectionObserver((rowEntries, rowObserver) => {
            rowEntries.forEach(rowEntry => {
              if (rowEntry.isIntersecting) {
                if(myntrAnalytics.debug) console.log("Intersecting a product list row.");
                pushViewItemList(itemList, rowItems);
                rowObserver.unobserve(rowEntry.target);
              }
            });
          }, itemRowOptions);
          rowObserver.observe(rowItems[0]);
        }
      }

      /**
      * Observe when an item list is intersected
      */
      function observeItemList(target) {
        const viewItemListObserver = new IntersectionObserver((entries, observer) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const itemList = entry.target;
              if(myntrAnalytics.debug) console.log("Intersecting a product list.", itemList);
              const itemSelector = itemList.dataset.datalayerItemListElement;
              const mobileRowCount = (itemList.hasAttribute('data-datalayer-item-list-columns-mobile')) ? parseInt(itemList.dataset.datalayerItemListColumnsMobile) : 2;
              const desktopRowCount = (itemList.hasAttribute('data-datalayer-item-list-columns-desktop')) ? parseInt(itemList.dataset.datalayerItemListColumnsDesktop) : 4;
              const items = Array.from(itemList.querySelectorAll(itemSelector)).filter(item => window.getComputedStyle(item).display !== 'none');
              const rowItemCount = window.innerWidth < 750 ? mobileRowCount : desktopRowCount; //TODO: make mobile window size a global variable per client
              observeListRows(itemList, items, rowItemCount);
              observer.unobserve(itemList); // we no longer want to trigger the intersection observer
              // As nodes may get added to the DOM, we want to build a list. When the list reaches the row count, push those nodes and then reset the list.
              let newRowItems = [];
              // there may be cases where an odd number of nodes are added that do not reach the rowItemCount, so after awhile let's check if we have any nodes left, and push that "final row"
              let debounceTimer = null;
              const debounceDelay = 3000;
              // Create a mutation observer for the itemList to look for new nodes added.
              const newRowsObserver = new MutationObserver((mutationsList, observer) => {
                mutationsList.forEach(({type, addedNodes}) => {
                  if (type === 'childList') {
                    addedNodes.forEach(node => {
                      // we only care for nodes that match the itemSelector, sometimes collection promos are injected and we won't push those.
                      if (node.nodeType === Node.ELEMENT_NODE && node.matches(itemSelector)) {
                        // Add the new node to the newRowItems
                        newRowItems.push(node);
                        // If newRowItems length hits the quota for rowItemCount
                        if (newRowItems.length === rowItemCount) {
                          // Observe the row and push it.
                          observeListRows(itemList, newRowItems, rowItemCount);
                          // Clear newRowItems to reset for the next batch.
                          newRowItems = [];
                        }
                      }
                    });
                    // Check if we still have added nodes here, push up whatever we have.
                    // ideally new nodes are injected a way where the above quota based code should run and push well before we hit this.
                    // this leaves this chunk to only deal with stragglers.
                    if (addedNodes.length > 0) {
                      clearTimeout(debounceTimer);
                      debounceTimer = setTimeout(() => {
                        if (newRowItems.length > 0) {
                          observeListRows(itemList, newRowItems, newRowItems.length);
                          newRowItems = [];
                        }
                      }, debounceDelay);
                    }
                  }
                });
              });
              newRowsObserver.observe(itemList, { childList: true, subtree: true }); // observe the list for new nodes.
            }
          });
        }, itemListOptions);
        viewItemListObserver.observe(target);
      }

      /**
      * Initiate the observers of an item list.
      */
      function initViewItemListObserver() {
        if(myntrAnalytics.debug) console.log(`%c initViewItemListObserver() `, "color:blue;font-size:16px;");
        // search the current document for "view_item_list" elements and observe them.
        Array.from(document.querySelectorAll(myntrSelectors.itemList)).forEach(observeItemList);

        // selector array of site zones we want to observe, this can change per-client.
        const listZones = ['#MainContent'];

        // create the observer function for these injected elements.
        const newItemListObserver = new MutationObserver((mutationsList, observer) => {
          mutationsList.forEach(({type, addedNodes}) => {
            if (type === 'childList') {
              addedNodes.forEach(node => {
                if (node.nodeType === Node.ELEMENT_NODE) {
                  // console.log(node);
                  if (node.matches(myntrSelectors.itemList)) {
                    observeItemList(node);
                  } else {
                    Array.from(node.querySelectorAll(myntrSelectors.itemList)).forEach((set)=>observeItemList(set));
                  }
                }
              });
            }
          });
        });

        // Loop through the selector array, if the selector is found to exist on the page, observe it for newly injected lists.
        listZones.forEach(listZone => {
          const zone = document.querySelector(listZone);
          if (zone) {
            newItemListObserver.observe(zone, { childList: true, subtree: true });
          }
        });
      }

      /*
        ReBuy Cart Drawer Upsell Events
        #CUSTOM CLIENT EVENT - REBUY
      */
      let rebuyTimer = null;
      function fetchAndPushRebuy(node) {
        if(!node) return;
        clearTimeout(rebuyTimer); // clear any existing timer
        rebuyTimer = setTimeout(() => {
          const anchorElement = node.querySelector('.rebuy-product-info a');
          if (anchorElement) {
            const href = anchorElement.getAttribute('href');
            const match = href.match(/(\/products\/.+?variant=\d+)/);
            if (!match) {
              console.error('Could not parse URL:', href);
              return;
            }
            const substring = match[1];
            const urlToFetch = `${substring}&view=datalayer`;

            fetch(urlToFetch)
              .then(response => response.json())
              .then(data => {
                data.item_list_name = "Mini Cart Upsell";
                data.item_list_id = "";
                if (myntrAnalytics.debug) console.log(`%c viewRebuyItemList() called.`, "color:green;font-size:16px;");
                // Push item, currently rebuy only shows one product at a time.
                pushEvent({ ecommerce: null }); // Clear previous ecommerce object
                pushEvent({
                  'event': 'view_item_list',
                  'ecommerce': {
                    'currency': dl_currency_code,
                    'items': [data]
                  }
                });
              })
              .catch((error) => {
                console.error('Error:', error);
              });
          }
        }, 200); // a slight delay is good enough.
      }

      function observeRebuyProductBlock(productBlock){
        // if (myntrAnalytics.debug) console.log("observeRebuyProductBlock()", productBlock);
        const blockObserver = new MutationObserver((mutationsList, observer) => {
          mutationsList.forEach(({ type }) => {
            if (type === 'attributes') {
              fetchAndPushRebuy(productBlock);
            }
          });
        });
        blockObserver.observe(productBlock, { attributes: true, attributeFilter: ['class'] });
      };

      function observeRebuyProductGrid(widgetNode) {
        // if (myntrAnalytics.debug) console.log("observeProductGrid()", widgetNode);
        const productGridObserver = new MutationObserver((mutationsList, observer) => {
          mutationsList.forEach(({ type, addedNodes, removedNodes }) => {
            if (type === 'childList') {
              addedNodes.forEach(node => {
                if (node.nodeType === Node.ELEMENT_NODE && node.matches('.rebuy-product-block')) {
                  fetchAndPushRebuy(node);
                  // Start observing the block for changes
                  observeRebuyProductBlock(node);
                }
              });

              // Watch for removed nodes
              removedNodes.forEach(node => {
                if (node.nodeType === Node.ELEMENT_NODE && node.matches('.rebuy-product-block')) {
                  // Handle removal of rebuy-product-block
                }
              });
            }
          });
        });

        const productGrid = widgetNode.querySelector('.rebuy-product-grid');
        if (productGrid) {
          productGridObserver.observe(productGrid, { childList: true, subtree: true });

          // Also check for any div.rebuy-product-block already present
          const existingBlocks = productGrid.querySelectorAll('.rebuy-product-block');
          existingBlocks.forEach(block => {
            const blockObserver = new IntersectionObserver((entries, observer) => {
              entries.forEach(entry => {
                if (entry.isIntersecting) {
                  fetchAndPushRebuy(block);
                  // Start observing the block for changes
                  observeRebuyProductBlock(block);
                }
              });
            });
            blockObserver.observe(block);
          });

        }
      }

      function initRebuyWidgetObserver(container) {
        // if (myntrAnalytics.debug) console.log("observeRebuyWidget()", container);
        const widgetObserver = new MutationObserver((mutationsList, observer) => {
          mutationsList.forEach(({ type, addedNodes }) => {
            if (type === 'childList') {
              addedNodes.forEach(node => {
                if (node.nodeType === Node.ELEMENT_NODE && node.matches('.rebuy-widget')) {
                  observeRebuyProductGrid(node);
                }
              });
            }
          });
        });
        // Start observing
        widgetObserver.observe(container, { childList: true, subtree: true });
        const existingWidget = container.querySelector('.rebuy-widget');
        if (existingWidget) {
          observeRebuyProductGrid(existingWidget);
        }
      }

      /**
      * Observe when the cart drawer is viewed
      */
      function initViewDynamicCartObserver() {
        const onCartDrawerVisible = (entries, observer) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              // push the cart view
              pushViewDynamicCart();
              // Observe the rebuy widget when the cartDrawer becomes visible
              initRebuyWidgetObserver(entry.target); // #CUSTOM CLIENT EVENT - REBUY
            }
          });
        };

        const options = {
          root: null,
          rootMargin: '0px',
          threshold: 0.5
        };

        const observer = new IntersectionObserver(onCartDrawerVisible, options);
        const cartDrawer = document.querySelector(myntrSelectors.dynamicCartForm);

        if (cartDrawer) {
          observer.observe(cartDrawer);
        } else {
          // Initialize cart open event if cart drawer is not found
          document.addEventListener('cart:drawer:open', (data) => {
            pushViewDynamicCart();
          },false);
        }
      }

      /**
      * Observe when quick view is viewed
      */
      function initViewDynamicProductObserver() {
        if(myntrAnalytics.debug) console.log(`%c initViewDynamicProductObserver() `, "color:blue;font-size:16px;");

        const productModal = document.querySelector('.js-product-modal');

        if (productModal) {
          const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
              if (mutation.type === 'attributes' && mutation.attributeName === 'data-datalayer-trigger') {
                if (productModal.getAttribute('data-datalayer-trigger') === 'view_item') {
                  pushViewDynamicItem(productModal);
                }
              }
            });
          });

          observer.observe(productModal, { attributes: true });
        }
      }

      /*
        =========================================================================================
          Push Events
        =========================================================================================
      */

      /**
      * Page View Event
      */
      function pushPageView(){

        {% liquid
          assign dl_page_category = ''
          assign dl_page_subcategory = ''
          assign dl_page_collection = ''
          assign template_object = false
          case template.name
            when 'article'
              assign template_object = article
            when 'blog'
              assign template_object = blog
            when 'collection'
              assign template_object = collection
            when 'page'
              assign template_object = page
            when 'product'
              assign template_object = product
          endcase
          if template_object
            assign dl_page_category = template_object.metafields.datalayer.page_category.value
            assign dl_page_subcategory = template_object.metafields.datalayer.page_subcategory.value
            assign dl_page_collection = template_object.metafields.datalayer.page_collection.value
          endif
        %}

        //Page data
        let dl_page_type = '{{- request.page_type -}}'; // home page, product detail page, terms & conditions, cart page, etc.
        const dl_customer_id = '{{- customer.id -}}';
        const dl_login_status = {% if customer %}true{% else %}false{% endif %};
        const dl_membership_status = '';
        const dl_page_category = '{{- dl_page_category -}}';
        const dl_page_subcategory = '{{- dl_page_subcategory -}}';
        const dl_page_collection = '{{- dl_page_collection -}}';

        //Checkout Page View
        {% if checkout %}
          dl_page_type = 'checkout';
        {% endif %}

        //Push event
        if(myntrAnalytics.debug) console.log(`%c pushPageView() page_view event.`, "color:green;font-size:16px;");

        pushEvent({
          'event': 'page_view',
          'page_type': dl_page_type,
          'page_category': dl_page_category,
          'page_subcategory': dl_page_subcategory,
          'page_collection': dl_page_collection,
          'user_id': dl_customer_id,
          'login_status': dl_login_status,
          'membership_status': dl_membership_status
        });
      }

      {% if template contains 'product' %}
      /**
      * Product Detail View Event
      */
      function pushViewItem(_item = null){

        //Timeout to correctly get swatch data
        setTimeout(() => { // #CUSTOM CLIENT EVENT - Timeout may NOT be needed!
          if(myntrAnalytics.debug) console.log(`%c pushViewItem() view_item event.`, "color:green;font-size:16px;");

          let item = {% render 'product-datalayer', _product: product %};
          if(_item != null) item = _item;

          //Selected Swatch Position
          // #CUSTOM CLIENT EVENT - Selected Swatch
          let pdpColorSwatches = document.querySelectorAll('.swatch__input');
          for (const swatch of pdpColorSwatches) {
            if (swatch.checked) {
              item.item_color_position = swatch.dataset.swatchPosition;
              break;
            }
          }
          if(myntrAnalytics.debug) console.log(`%c Selected Swatch Postion: ${item.item_color_position}`, "color:green;font-size:16px;");

          // Push Product Click Event
          pushProductClick(item);

          // Push View Item Event
          pushEvent({ ecommerce: null }); // Clear previous ecommerce object
          pushEvent({
            'event': 'view_item',
            'ecommerce': {
              'currency': dl_currency_code,
              'items': [item]
            }
          });
        }, 2000);
      }// END: pushViewItem()

      /**
      * Product Click Event
      */
      function pushProductClick(item) {

        //must have a link previously clicked within session storage
        if(!sessionStorage.getItem(myntrAnalytics.sessionStorageProductClick)) return;

        if(myntrAnalytics.debug) console.log(`%c pushProductClick() called`, "color:green;font-size:16px;");

        //get link from storage
        const href = sessionStorage.getItem(myntrAnalytics.sessionStorageProductClick);
        const href_handle = href.split('products/').pop().split('?')[0];

        //remove link from storage
        sessionStorage.removeItem(myntrAnalytics.sessionStorageProductClick);

        if(href_handle != '{{ product.handle }}') return;

        // Push Data Layer Event
        pushEvent({ ecommerce: null }); // Clear previous ecommerce object
        pushEvent({
          'event': 'select_item',
          'filters_applied': '', //TODO: get filters applied if coming from PLP
          'ecommerce': {
            'currency': dl_currency_code,
            'items': [item]
          }
        });
      }
      {% endif %}

      /**
      * Product Quick View Event
      */
      async function pushViewDynamicItem(trigger){

        const productHandle = trigger.dataset.viewItemHandle;

        const item = await fetchProduct(productHandle);

        //Selected Swatch Postion
        // #CUSTOM CLIENT EVENT - Selected Swatch
        let pdpColorSwatches = document.querySelectorAll('.swatch__input');
        for (const swatch of pdpColorSwatches) {
          if (swatch.checked) {
            item.item_color_position = swatch.dataset.swatchPosition;
            break;
          }
        }
        if(myntrAnalytics.debug) console.log(`%c Selected Swatch Postion: ${item.item_color_position}`, "color:green;font-size:16px;");

        //Push event
        if(myntrAnalytics.debug) console.log(`%c pushViewItem() view_item event.`, "color:green;font-size:16px;");

        pushEvent({ ecommerce: null }); // Clear previous ecommerce object
        pushEvent({
          'event': 'view_item',
          'ecommerce': {
            'currency': dl_currency_code,
            'items': [item]
          }
        });

      }// END: pushViewDynamicItem()

      /**
      * Product Add to Cart Event
      */
      async function pushAddToCart(data){
        if(myntrAnalytics.debug) console.log(`%c pushAddToCart() called.`, "color:green;font-size:16px;");
        if(!data) return;

        //Add to Cart Location
        const event = data.detail.event;
        let event_source = ""

        //Set default add to cart locations based on liquid templates
        let dl_add_to_cart_location = '';
        {% if template contains 'product' %}
          dl_add_to_cart_location = add_to_cart_locations.pdp_add_to_cart;
        {% elsif template contains 'collection' %}
          dl_add_to_cart_location = add_to_cart_locations.plp_quick_view;
        {% elsif template contains 'index' %}
          dl_add_to_cart_location = add_to_cart_locations.home_page_add_to_cart;
        {% elsif template contains 'page' %}
          dl_add_to_cart_location = add_to_cart_locations.landing_page_add_to_cart;
        {% elsif template contains 'search' %}
          dl_add_to_cart_location = add_to_cart_locations.search_page_add_to_cart;
        {% elsif template contains 'cart' %}
          dl_add_to_cart_location = add_to_cart_locations.cart_upsell;
        {% else %}
          dl_add_to_cart_location = '{{ template.name | capitalize }} Add To Cart'
        {% endif %}

        if(event){
          if(myntrAnalytics.debug) console.log(event);
          const event_type = event?.type;

          //Determine more specific add to cart location
          if (event_type && add_to_cart_locations[event_type]) {
            dl_add_to_cart_location = add_to_cart_locations[event_type];
          }
          else if(event_type && event_type == "quick_view"){
            {% if template contains 'product' %}
              dl_add_to_cart_location = add_to_cart_locations.pdp_upsell;
            {% elsif template contains 'collection' %}
              dl_add_to_cart_location = add_to_cart_locations.plp_quick_view;
            {% elsif template contains 'index' %}
              dl_add_to_cart_location = add_to_cart_locations.home_page_quick_view;
            {% elsif template contains 'page' %}
              dl_add_to_cart_location = add_to_cart_locations.landing_page_quick_view;
            {% elsif template contains 'search' %}
              dl_add_to_cart_location = add_to_cart_locations.search_page_quick_view;
            {% elsif template contains 'cart' %}
              dl_add_to_cart_location = add_to_cart_locations.cart_page_quick_view;
            {% else %}
              dl_add_to_cart_location = '{{ template.name | capitalize }} Add To Cart'
            {% endif %}
          }
        }

        // Get product data
        let items = [];

        //fetch cart items in datalayer format
        const cart = await fetchCart();

        //iterate over items added
        for(const product of data.detail.items){

          //find matching cart item
          let cart_item = cart.items.find((i) => i.item_variant_id == product.id);
          if(myntrAnalytics.debug) console.log(cart_item);
          if(!cart_item) return;

          // Selected Swatch Postion
          // #CUSTOM CLIENT EVENT - Selected Swatch
          let pdpColorSwatches = document.querySelectorAll('.js-product-option-color');
          for (const swatch of pdpColorSwatches) {
            if (swatch.checked) {
              cart_item.item_color_position = swatch.dataset.swatchPosition;
              break;
            }
          }
          if(myntrAnalytics.debug) console.log(`%c Selected Swatch Postion: ${cart_item.item_color_position}`, "color:green;font-size:16px;");

          //Update quantity
          cart_item.quantity = parseInt(product.quantity);

          //Push item to array
          items.push(cart_item);
        }

        if(items.length == 0) return;

        //Push event
        pushEvent({ ecommerce: null }); // Clear previous ecommerce object
        pushEvent({
          'event': 'add_to_cart',
          'add_to_cart_location': dl_add_to_cart_location,
          'ecommerce': {
            'currency': dl_currency_code,
            'items': items
          }
        });

      }// END: pushAddToCart()


      /**
      * Product Update/Remove Event
      */
      async function pushCartItemQuantityChange(data){
        if(myntrAnalytics.debug) {
          console.log(`%c pushCartItemQuantityChange() called.`, "color:green;font-size:16px;");
          console.log(data.detail);
        }
        if(!data) return;

        const event_type = data.detail.event?.type;
        let dl_event_location = '';
        if(event_type && event_type === 'add_to_cart'){
          dl_event_location = add_to_cart_locations.mini_cart_qty_increase;
        }

        // Get product data
        let items = [];

        //fetch cart items in datalayer format
        const cart = await fetchCart();

        //iterate over items added
        for(const product of data.detail.items){
          //find matching cart item
          let cart_item = cart.items.find((i) => i.item_variant_id == product.id);

          //if no matching item in cart, fetch the product template
          if(!cart_item){
            if(product.handle){
              cart_item = await fetchProduct(product.handle, product.id)
            } else {
              return
            }
          }

          if(myntrAnalytics.debug) console.log(cart_item);

          //Update quantity
          if(data.detail.event?.quantity_changed) {
            cart_item.quantity = parseInt(data.detail.event?.quantity_changed);
          }

          //Push item to array
          items.push(cart_item);
        }

        if(items.length == 0) return;

        //create event object
        let eventObj = {
          'event': event_type,
          'ecommerce': {
            'currency': dl_currency_code,
            'items': items
          }
        };

        // if we have an event location, send it up.
        if(dl_event_location != ''){
          eventObj['add_to_cart_location'] = dl_event_location;
        }

        //Push event
        pushEvent({ ecommerce: null }); // Clear previous ecommerce object
        pushEvent(eventObj);
      }// END: pushCartItemQuantityChange()


      /**
      * Minicart View Event
      */
      async function pushViewDynamicCart(){
        if(myntrAnalytics.debug) console.log(`%c pushViewDynamicCart() called.`, "color:green;font-size:16px;");

        const cart = await fetchCart();

        if(cart.items.length == 0 ) return;

        pushEvent({ ecommerce: null }); // Clear previous ecommerce object

        pushEvent({
          'event': 'view_cart',
          'ecommerce': {
            'currency': dl_currency_code,
            'value': cart.total_price,
            'checkout_step': 1,
            // 'checkout_option': '',
            'gift': cart.gift,  // Is the order a gift?  true or false value only
            // #CUSTOM CLIENT EVENT -- KM uses cart notes to denote an order as a gift or not.
            'items': cart.items
          }
        });
      }

      /**
      * Cart Page View Event
      */
      async function pushViewStaticCart(){
        if(myntrAnalytics.debug) console.log(`%c pushViewStaticCart() called.`, "color:green;font-size:16px;");

        const cart = await fetchCart();

        if(cart.items.length == 0 ) return;

        pushEvent({ ecommerce: null }); // Clear previous ecommerce object
        pushEvent({
          'event': 'view_cart',
          'ecommerce': {
            'currency': dl_currency_code,
            'value': cart.total_price,
            'checkout_step': 1,
            // 'checkout_option': '',
            'gift': cart.gift,  // Is the order a gift?  true or false value only
            // #CUSTOM CLIENT EVENT -- KM uses cart notes to denote an order as a gift or not.
            'items': cart.items
          }
        });
      }

      /**
      * Fetch cart template with item data layer values
      */
      function fetchCart() {
        return fetch('/cart?view=datalayer', { method: 'GET' })
        .then(response => response.json())
        .then((data) => {
          return data;
        })
        .catch((error) => {
          console.error(error);
        });
      }

      /**
      * Fetch product template with data layer values
      */
      function fetchProduct(handle, variantID = null, sellingPlanID = null) {
        if(!handle) return;

        let variantParam = "";
        let sellingPlanParam = "";

        if(variantID) {
          variantParam = `?variant=${variantID}`;
        }

        if(sellingPlanID) {
          sellingPlanParam = `${sellingPlanID}`;
        }

        return fetch(`/products/${handle}${variantParam}${sellingPlanParam}&view=datalayer`, { method: 'GET' })
        .then(response => response.json())
        .then((data) => {
          return data;
        })
        .catch((error) => {
          console.error(error);
        });
      }

      /**
      * Item List View Event
      */
      async function pushViewItemList(itemList, nodeArray){
        if(myntrAnalytics.debug) console.log(`%c pushViewItemList() called.`, "color:green;font-size:16px;");
        if(myntrAnalytics.debug) console.log(nodeArray);
        if(!nodeArray) return;

        //create datalayer items array
        let items = [];
        let itemListId = "";
        let itemListName = "";
        if(itemList){
          itemListId = itemList.dataset.datalayerItemListId;
          itemListName = itemList.dataset.datalayerItemListName;
        }
        for (const element of nodeArray) {
          try {
            if(!element.querySelector('script[data-datalayer-product-json]')){
              // look for a product link, fetch the product from that link.
              const anchorElement = Array.from(element.querySelectorAll('a')).find(a => a.href.includes('/products/'));

              if (anchorElement) {
                const href = anchorElement.getAttribute('href');
                const match = href.match(/\/products\/([^\/]+)/);
                if (match) {
                  const productHandle = match[1];
                  const productData = await fetchProduct(productHandle);
                  if(productData !== null){
                    if(itemListId){
                      productData.item_list_id = itemListId;
                    }
                    if(itemListName){
                      productData.item_list_id = itemListName;
                    }
                    items.push(productData);
                  }
                }
              }
            } else {
              const scriptContent = element.querySelector('script[data-datalayer-product-json]').textContent;
              try {
                const data = JSON.parse(scriptContent);
                if(itemListId){
                  data.item_list_id = itemListId;
                }
                if(itemListName){
                  data.item_list_id = itemListName;
                }
                items.push(data);
              } catch (err) {
                if(myntrAnalytics.debug) console.log('Error parsing JSON:', err);
              }
            }
          } catch (err) {
            if(myntrAnalytics.debug) console.log('Error in pushViewItemList:', err);
          }
        }

        if(items.length == 0){
          if(myntrAnalytics.debug) console.log("items list is empty")
          return;
        }

        pushEvent({ ecommerce: null }); // Clear previous ecommerce object
        pushEvent({
          'event': 'view_item_list',
          'ecommerce': {
            'currency': dl_currency_code,
            'items': items
          }
        });
      }

      /**
      * Promotion View Event
      */
      function pushViewPromotion(trigger){
        if(myntrAnalytics.debug) console.log(`%c pushViewPromotion() called.`, "color:green;font-size:16px;");
        if(!trigger) return;

        pushEvent({ ecommerce: null }); // Clear previous ecommerce object
        pushEvent({
          'event': 'view_promotion',
          'ecommerce': {
            'items': [
              {
                'promotion_id': (!!trigger.dataset.gtmPromotionId) ? trigger.dataset.gtmPromotionId : "",
                'promotion_name': (!!trigger.dataset.gtmPromotionName) ? trigger.dataset.gtmPromotionName : "",
                'creative_name': (!!trigger.dataset.gtmCreativeName) ? trigger.dataset.gtmCreativeName : "",
                'creative_slot': (!!trigger.dataset.gtmCreativeSlot) ? trigger.dataset.gtmCreativeSlot : "",
                'location_id': (!!trigger.dataset.gtmLocationId) ? trigger.dataset.gtmLocationId : ""
                // TODO: ,[[PRODUCT DATA]] // If promotion is for a specific product
              }
            ]
          }
        });
      }

      /**
      * Promotion Select Event
      */
      function pushSelectPromotion(trigger,event){
        if(myntrAnalytics.debug) console.log(`%c pushSelectPromotion() called.`, "color:green;font-size:16px;");
        if(!trigger) return;
        if(!trigger.contains(event.target)) return; //ensure click event was within promotion

        pushEvent({ ecommerce: null }); // Clear previous ecommerce object
        pushEvent({
          'event': 'select_promotion',
          'ecommerce': {
            'items': [
              {
                'promotion_id': (!!trigger.dataset.gtmPromotionId) ? trigger.dataset.gtmPromotionId : "",
                'promotion_name': (!!trigger.dataset.gtmPromotionName) ? trigger.dataset.gtmPromotionName : "",
                'creative_name': (!!trigger.dataset.gtmCreativeName) ? trigger.dataset.gtmCreativeName : "",
                'creative_slot': (!!trigger.dataset.gtmCreativeSlot) ? trigger.dataset.gtmCreativeSlot : "",
                'location_id': (!!trigger.dataset.gtmLocationId) ? trigger.dataset.gtmLocationId : ""
                // TODO: ,[[PRODUCT DATA]] // If promotion is for a specific product
              }
            ]
          }
        });
      }

      /**
      * Navigation Click Event
      */
      function pushNavigationClick(trigger){
        if(myntrAnalytics.debug) console.log(`%c pushNavigationClick() called.`, "color:green;font-size:16px;");
        if(!trigger) return;

        //get click location based on data attribute of parent navigation element
        let clickLocation = '';
        let clickLocationElement = trigger.closest(myntrSelectors.navigationClickTriggerLocation);
        if(clickLocationElement){
          clickLocation = clickLocationElement.dataset.datalayerNavigationClickLocation
        }

        pushEvent({
          'event': 'navigation_click',
          'click_location': clickLocation,
          'link_text': trigger.textContent.replace(/(\r\n|\n|\r)/gm, "").replace(/\s+/g, ' ').trim(),
          'destination_url': trigger.href
        });

      }

      /**
      * Account Register Event
      */
      function pushAccountRegister(){
        if(myntrAnalytics.debug) console.log(`%c pushAccountRegister() called.`, "color:green;font-size:16px;");
        pushEvent({
          'event': 'account_register',
          'user_id': '{{- customer.id -}}'
        });
      }

      /**
      * Account Login Event
      */
      function pushAccountLogin(){
        if(myntrAnalytics.debug) console.log(`%c pushAccountLogin() called.`, "color:green;font-size:16px;");
        pushEvent({
          'event': 'account_login',
          'user_id': '{{- customer.id -}}'
        });
      }

      /**
      * Determine Email Opt In for default Shopify contact form
      */
      function determineEmailOptin(){
        if(myntrAnalytics.debug) console.log(`%c determineEmailOption`, "color:green;font-size:16px;");
        if(sessionStorage.getItem(myntrAnalytics.sessionStorageEngagementEmail)){
          // we only want to push for valid submissions, let's check the URL parameter for the one we know from Shopify.
          // grab the URL params
          let params = new URLSearchParams(window.location.search);
          // Check if 'customer_posted' parameter exists and equals 'true'
          if (params.has('customer_posted') && params.get('customer_posted') === 'true') {
            //get the email from storage, in case we need to send it
            const email = sessionStorage.getItem(myntrAnalytics.sessionStorageEngagementEmail);

            // push the email opt in, send the email in the event we also want to send that along.
            pushEmailOptin(email);

            //remove link from storage
            sessionStorage.removeItem(myntrAnalytics.sessionStorageEngagementEmail);
          }
        }
      }

      /**
      * Email Opt In
      */
      function pushEmailOptin(email){
        if(!email) return;
        if(myntrAnalytics.debug) console.log(`%c pushEmailOptin`, "color:green;font-size:16px;");
        pushEvent({
          'event': 'email_optin'
        });
      }

      {% if checkout %}
        /**
        * checkout.liquid Checkout Steps
        * This code has a lifespan until August 2024!
        * https://changelog.shopify.com/posts/the-checkout-liquid-theme-file-is-being-deprecated
        */
        async function pushCheckout(){
          if(!Shopify.Checkout || !Shopify.Checkout.step || Shopify.Checkout.step == 'thank_you') return;

          if(myntrAnalytics.debug) console.log(`%c pushCheckout() called.`, "color:green;font-size:16px;");

          //determine event name and step number
          let event, step;
          switch (Shopify.Checkout.step) {
            case "contact_information":
              event = "contact info"
              step = '2'
              break;
            case "shipping_method":
              event = "shipping method"
              step = '3'
              break;
            case "payment_method":
              event = "payment"
              step = '4'
              break;
            default:
              break;
          }

          //get checkout line item datalayer values
          {% capture checkout_items_datalayer %}
            [
            {%- for line_item in checkout.line_items -%}
              {%- render 'product-datalayer',
                _product: line_item.product,
                _variant: line_item.variant,
                _quantity: line_item.quantity,
                _line_item: line_item
              -%}
              {%- unless forloop.last %},{%- endunless -%}
            {%- endfor -%}
            ]
          {% endcapture %}

          const items = {{- checkout_items_datalayer | strip_newlines -}};

          if(items.length == 0 ) return;

          // push event
          pushEvent({ ecommerce: null }); // Clear previous ecommerce object

          pushEvent({
            'event': event,
            'ecommerce': {
              'currency': {{ checkout.currency | json }},
              'value': {{ checkout.total_price | money_without_currency }},
              'checkout_step': step,
              //'checkout_option': option,
              'gift': {% if checkout.note != blank %}true{% else %}false{% endif %}, // Is the order a gift?  true or false value only
              // #CUSTOM CLIENT EVENT -- KM uses cart notes to denote an order as a gift or not.
              'items': items
            }
          });

        }
      {% endif %}

      /*
        =========================================================================================
          Main Thread
        =========================================================================================
      */

      function myntrDataLayer(){
        if(myntrAnalytics.debug) console.log(`%c myntrDataLayer() called.`, "color:green;font-size:16px;");

        // push the page view event
        pushPageView();

        {% if template contains 'product' %}
          // push the view product event if we are on a product page
          pushViewItem();
        {% endif %}

        {% if template contains 'cart' %}
          // push the view cart event if we are on the cart page
          pushViewStaticCart();
        {% endif %}

        {% if template contains 'customer' and customer %}
          // Initialize account_register and account_login events
          const accountRegister = document.querySelector(myntrSelectors.accountRegister);
          const accountLogin = document.querySelector(myntrSelectors.accountLogin);
          if(accountRegister) pushAccountRegister();
          if(accountLogin) pushAccountLogin();
        {% endif %}

        // Initalize our event listeners.
        setTimeout(() =>{
          initEventListeners();
        }, 100);

        // Initialize our observers
        initObservers();

        // Checkout Step Events
        {% if checkout %}
          pushCheckout();
        {% endif %}

        // part 2 of default Shopify email opt-in, on document load check if we can pushEmailOptin
        determineEmailOptin();

      } //END: myntrDataLayer();


      // Start DataLayer on Document Ready
      function docReady(fn) {
        document.addEventListener("DOMContentLoaded", fn);
        if (document.readyState === "interactive" || document.readyState === "complete" ) {
          fn();
        }
      }

      docReady(() => {
        myntrDataLayer();
      });

    } catch (error) {
      console.log(`%c Custom GA4 error caught`, "color:red;font-size:16px;");
      console.log(error);
    }

  })();
</script>
